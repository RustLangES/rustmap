---
title: 'Cargo'
description: ''
draft: true
data:
  type: 'custom'
  topicLevel: 'start'
  position:
    x: 200
    y: 750
  sourcePosition:
    error-handling: 'right'
  targetPosition:
    traits: 'bottom'
---
# Organizando Proyectos en Rust: MÃ³dulos y Visibilidad

Cuando desarrollamos en Rust, mantener el cÃ³digo organizado es esencial para la escalabilidad y la mantenibilidad. Rust ofrece un sistema de mÃ³dulos flexible que nos ayuda a dividir el cÃ³digo en componentes mÃ¡s manejables. En este artÃ­culo exploraremos cÃ³mo crear y gestionar mÃ³dulos, controlar su visibilidad, y estructurar proyectos de manera eficiente, abordando las prÃ¡cticas mÃ¡s recomendadas en la comunidad.

---

## IntroducciÃ³n a los mÃ³dulos

Los mÃ³dulos en Rust agrupan cÃ³digo relacionado bajo un espacio de nombres, permitiendo:

- **OrganizaciÃ³n lÃ³gica:** Divide el cÃ³digo en archivos o directorios.
- **EncapsulaciÃ³n:** Restringe quÃ© partes del cÃ³digo son accesibles externamente.
- **ReutilizaciÃ³n:** Facilita la modularidad y el uso compartido de cÃ³digo.

Un mÃ³dulo puede contener funciones, estructuras, enumeraciones, constantes e incluso otros mÃ³dulos.

---

## Crear y gestionar mÃ³dulos

### MÃ³dulos en el mismo archivo
La forma mÃ¡s sencilla de declarar un mÃ³dulo es hacerlo directamente en el archivo:

```rust
mod math {
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }
}
```

Luego accedes a los elementos pÃºblicos con el prefijo del mÃ³dulo:
```rust
fn main() {
    let sum = math::add(2, 3);
    println!("Suma: {}", sum);
}
```

### MÃ³dulos en archivos separados
Para mantener el cÃ³digo limpio, puedes mover los mÃ³dulos a archivos independientes:

En `main.rs`:
```rust
mod math;

fn main() {
    let sum = math::add(5, 7);
    println!("Suma: {}", sum);
}
```

En `math.rs`:
```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### MÃ³dulos como directorios
Si un mÃ³dulo incluye submÃ³dulos, puedes organizarlo en un directorio con un archivo `mod.rs` o estructurarlo usando archivos con el mismo nombre que los submÃ³dulos.

Estructura de ejemplo:
```
src/
â”œâ”€â”€ main.rs
â”œâ”€â”€ math/
â”‚   â”œâ”€â”€ mod.rs
â”‚   â”œâ”€â”€ add.rs
â”‚   â””â”€â”€ multiply.rs
```

En `math/mod.rs`:
```rust
pub mod add;
pub mod multiply;
```

---

## Control de visibilidad

Por defecto, los mÃ³dulos y sus elementos son privados. Para hacerlos accesibles, usa `pub`.

```rust
mod shapes {
    pub struct Rectangle {
        pub width: u32,
        pub height: u32,
    }

    impl Rectangle {
        pub fn area(&self) -> u32 {
            self.width * self.height
        }
    }
}
```

El acceso desde otro mÃ³dulo o funciÃ³n serÃ¡ asÃ­:
```rust
fn main() {
    let rect = shapes::Rectangle { width: 10, height: 20 };
    println!("Ãrea: {}", rect.area());
}
```

---

## EstructuraciÃ³n recomendada para proyectos Rust

La organizaciÃ³n de un proyecto depende de su propÃ³sito. AquÃ­ hay patrones comunes:

### 1. **Proyectos ejecutables simples**
Los proyectos pequeÃ±os suelen tener un Ãºnico archivo `main.rs`:

```
src/
â””â”€â”€ main.rs
```

### 2. **Proyectos ejecutables grandes**
A medida que crece, puedes mover lÃ³gica a mÃ³dulos:

```
src/
â”œâ”€â”€ main.rs
â”œâ”€â”€ config.rs
â”œâ”€â”€ handlers.rs
â””â”€â”€ utils.rs
```

En `main.rs`:
```rust
mod config;
mod handlers;
mod utils;
```

### 3. **Bibliotecas**
Las bibliotecas usan un archivo `lib.rs` para exponer su API pÃºblica:

```
src/
â”œâ”€â”€ lib.rs
â””â”€â”€ utils.rs
```

En `lib.rs`:
```rust
pub mod utils;
```

### 4. **HÃ­bridos (ejecutable + biblioteca)**
Un proyecto puede tener `main.rs` para la aplicaciÃ³n y `lib.rs` para lÃ³gica reutilizable:

```
src/
â”œâ”€â”€ lib.rs
â””â”€â”€ main.rs
```

En `main.rs`:
```rust
use mycrate::utils::some_function;

fn main() {
    some_function();
}
```

En `lib.rs`:
```rust
pub mod utils {
    pub fn some_function() {
        println!("FunciÃ³n compartida");
    }
}
```

### 5. **Proyectos con mÃºltiples binarios**
Usa un directorio `src/bin/` para incluir otros ejecutables:

```
src/
â”œâ”€â”€ main.rs
â”œâ”€â”€ lib.rs
â””â”€â”€ bin/
    â”œâ”€â”€ tool1.rs
    â””â”€â”€ tool2.rs
```

---

## Puntos de entrada: `main.rs` y `lib.rs`

### `main.rs`
Es el punto de entrada de los ejecutables. AquÃ­ defines la lÃ³gica inicial de tu programa.

### `lib.rs`
Sirve como punto de entrada para bibliotecas. AquÃ­ defines quÃ© mÃ³dulos y funciones serÃ¡n pÃºblicos para los usuarios de la biblioteca.

### Coexistencia de `main.rs` y `lib.rs`
En proyectos hÃ­bridos, `lib.rs` puede contener la lÃ³gica principal reutilizable y `main.rs` consumirla:

En `lib.rs`:
```rust
pub fn greet(name: &str) {
    println!("Hola, {}!", name);
}
```

En `main.rs`:
```rust
use mycrate::greet;

fn main() {
    greet("Mundo");
}
```

---

## Buenas prÃ¡cticas y convenciones

1. **Divide y vencerÃ¡s:** Usa mÃ³dulos para separar responsabilidades.
2. **RestricciÃ³n de visibilidad:** Haz pÃºblicos solo los elementos necesarios.
3. **Nombres consistentes:** Usa nombres descriptivos para mÃ³dulos y archivos.
4. **Centraliza lo comÃºn:** Mueve funciones reutilizables a `lib.rs`.

---

## Configuraciones adicionales para mÃ³dulos

- **AgrupaciÃ³n lÃ³gica:** Usa directorios para mÃ³dulos con mÃºltiples submÃ³dulos.
- **Macros compartidas:** Crea un mÃ³dulo separado para macros reutilizables, por ejemplo, `src/macros.rs`.

---

## ConclusiÃ³n

Organizar proyectos con mÃ³dulos en Rust no solo mejora la claridad del cÃ³digo, sino que tambiÃ©n facilita su escalabilidad. Ya sea que trabajes en un ejecutable, una biblioteca o ambos, seguir estas prÃ¡cticas te ayudarÃ¡ a mantener un cÃ³digo limpio, reutilizable y fÃ¡cil de entender. Â¡Experimenta con estas tÃ©cnicas y lleva tus proyectos al siguiente nivel! ğŸš€
